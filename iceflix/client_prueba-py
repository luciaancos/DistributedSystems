#!/usr/bin/env python3
import logging
import sys
import getpass
from hashlib import sha256
import threading
import time
from cmd_prueba import Client_cmd

import Ice

try:
    import IceFlix  # pylint:disable=import-error

except ImportError:
    import os
    Ice.loadSlice(os.path.join(os.path.dirname(__file__),"iceflix.ice"))
    import IceFlix

LOG_FORMAT = '%(asctime)s - %(levelname)-7s - %(module)s:%(funcName)s:%(lineno)d - %(message)s'

logging_ = logging.getLogger('CLIENT_APPLICATION')
logging_.setLevel(logging.DEBUG)

# create console handler and set level to debug
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# create formatter
formatter = logging.Formatter('%(asctime)s - %(levelname)-7s - %(module)s:%(funcName)s:%(lineno)d - %(message)s')

# add formatter to ch
console_handler.setFormatter(formatter)

# add ch to logger
logging_.addHandler(console_handler)

class Client(Ice.Application):

    def run(self, argv):
        comm = self.communicator()
        for i in range(3):
                main_proxy_string = input("Please, introduce the main proxy:")
                try:
                    main_proxy = comm.stringToProxy(main_proxy_string)
                    main_obj = IceFlix.MainPrx.checkedCast(main_proxy)

                    if main_obj:
                        print("Successfully connected")
                        break
                    else:
                        print("Incorrect proxy. Please try again, ", 2-i, "remaining oportunities.")
                        time.sleep(5)
                        return -1
                except Ice.NoEndpointException:
                    print("Sorry, it does not connect,  ", 2-i, "remaining oportunities" )
                # except (Ice.TemporaryUnavailable):
                #     logging.error("Sorry, the main service is not available") 
                #     print("Please try again, ", 2-i, "remaining oportunities.")

        adapter = comm.createObjectAdapterWithEndpoints("ClientAdapter", "tcp")
        client_cmd = Client_cmd(main_obj)
        threading.Thread(target=client_cmd.cmdloop(),args= main_obj).start()
        
        comm.waitForShutdown()
        

if __name__ == "__main__":
    sys.exit(Client().main(sys.argv))